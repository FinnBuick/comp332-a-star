/*
 * This file is part of COMP332 Assignment 1.
 *
 * Copyright (C) 2018 Dominic Verity, Macquarie University.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * The code in this module creates a doodle image from the information
 * returned from the path planning function.
 */

import doodle.core._
import doodle.core.Image._
import doodle.syntax._

import scala.math.Ordering.Implicits._

import PathPlanner._

/**
  * The following class encapsulates the data returned from the A^* path planning
  * algorithm. It is a quadruple comprising:
  *
  *     -   A reference to the `PathPlanner` object representing the map that the
  *         planned path navigates.
  *     -   The coordinates of the start and target cells of the computed path.
  *     -   The visit record of the last step of the computed path, ending at
  *         at the target location. We may follow the sequence of `last` pointers
  *         from there to find the actual path traversed.
  *     -   The set containing visit records for all of the locations visited
  *         in the search.
  *     -   The fringe heap containing the cells left in the fringe at the end
  *         of the search.
  *
  * This class also provides a field which renders this information as a Doodle image.
  */
class PathPlan (map : PathPlanner, start : Loc, target : Loc,
                terminus : VisitRecord, visited : VisitedSet, fringe : FringeHeap) {
  // Import definitions from companion object.
  import PathPlan._

  // Success flag, is `true` if a path has been successfully planned from
  // start to target.
  val success : Boolean = (target equiv terminus.loc)

  // Transfer the records in the fringe heap into a set for easy interrogation.
  lazy val fringeSet : BTree[Loc] = BTree(fringe.inOrder.map(_.value.loc))
  lazy val pathSet : BTree[Loc] = BTree(terminus.toPath)
  lazy val closedSet : BTree[Loc] = BTree(visited.inOrder.map(_.loc))

  /**
    * A Doodle image constructed from the information generated by the A*
    * path planning algorithm.
    */
  lazy val mapImage : Image = {
    val height : Int = 24
    val width : Int = 24

    val cells : Seq[Seq[Image]] =
      for {
        y <- 1 to height
        row = for {
          x <- 1 to width

            image =
              Image.square(20)

            } yield image
          } yield row

          collapseToMapImage(cells)
        }

}


/**
  * Companion object for the `PathPlan` class. Mainly constants used when
  * constructing the map image.
  */
object PathPlan {

  // Constants specifying the sizes of various drawing components
  val cellSize : Int = 24
  val cellEdgeWidth : Int = 1
  val frameWidth : Int = 10

  // Constants specifying the colours to display different kinds of cell in.
  val obstacleColour : Color = Color.darkSlateBlue
  val fringeColour : Color = Color.darkGreen
  val pathColour : Color = Color.gold
  val closedColour : Color = Color.lightGreen
  val terminusColour : Color = Color.red
  val terminusBackground : Color = Color.royalBlue

  def collapseToRowImage(images : Seq[Image]) : Image =
    images.toList match {
      case Nil => Image.empty
      case (x :: xs) => x beside collapseToRowImage(xs)
    }


  def collapseToMapImage(images : Seq[Seq[Image]]) : Image =
    images.toList match {
      case Nil => Image.empty
      case (y :: ys) => collapseToRowImage(y) above collapseToMapImage(ys)

    }

}
